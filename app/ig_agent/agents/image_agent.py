"""
Image generation agent for Instagram posts
"""

import os
import logging
from pathlib import Path
from typing import Dict, Any, List
from langchain_core.messages import HumanMessage

logger = logging.getLogger("ig_agent.image_agent")

class ImageAgent:
    """
    Agent responsible for generating Instagram images from content
    """
    
    def __init__(self, llm=None, prompt_path=None, templates_dir=None, output_dir=None):
        """
        Initialize the ImageAgent
        
        Args:
            llm: Language model instance (optional)
            prompt_path: Path to image generation prompt
            templates_dir: Directory containing SVG templates
            output_dir: Directory to save generated images
        """
        self.llm = llm
        self.prompt_path = prompt_path or os.path.join(
            os.path.dirname(os.path.dirname(__file__)), 
            "prompts", 
            "images_generation.txt"
        )
        
        # Set templates directory
        if templates_dir:
            self.templates_dir = Path(templates_dir)
        else:
            self.templates_dir = Path(os.path.dirname(os.path.dirname(__file__))) / "static"
        
        # Set output directory
        self.output_dir = output_dir
        
        # Load prompt
        if os.path.exists(self.prompt_path):
            with open(self.prompt_path, 'r') as f:
                self.prompt = f.read()
    
    def generate_images(self, content_json: Dict[str, Any], output_dir: str = None) -> List[Dict[str, Any]]:
        """
        Generate images from content JSON
        
        Args:
            content_json: Content generated by content_agent
            output_dir: Directory to save generated images (overrides init value)
            
        Returns:
            list: Metadata about generated images
        """
        # Use provided output_dir or the one set during initialization
        output_dir = output_dir or self.output_dir
        if not output_dir:
            raise ValueError("Output directory is required")
        
        # Create output directory if it doesn't exist
        os.makedirs(output_dir, exist_ok=True)
        
        try:
            # Try SVG-based approach first
            from ..templates.template_processor import TemplateProcessor
            
            # Initialize template processor
            processor = TemplateProcessor(self.templates_dir, output_dir)
            
            # Process cover image
            cover_path = processor.generate_cover(content_json.get("cover", {}))
            
            # Process content images
            content_paths = []
            for i, page in enumerate(content_json["content_pages"]):
                page_number = i + 1
                content_path = processor.generate_content_page(
                    page, 
                    page_number,
                    with_image="illustration_description" in page and page["illustration_description"]
                )
                content_paths.append(content_path)
            
            # Create image metadata
            images = [
                {
                    "type": "cover",
                    "path": str(cover_path),
                    "file_name": os.path.basename(cover_path),
                    "status": "generated"
                }
            ]
            
            for i, path in enumerate(content_paths):
                images.append({
                    "type": "content",
                    "page_number": i + 1,
                    "path": str(path),
                    "file_name": os.path.basename(path),
                    "status": "generated"
                })
            
            logger.info(f"Generated {len(images)} images using SVG templates")
            return images
            
        except Exception as e:
            logger.warning(f"SVG template approach failed: {str(e)}. Falling back to PIL-based image generation")
            
            # Fallback to PIL-based image generation
            return self._generate_images_with_pil(content_json, output_dir)
    
    def _generate_images_with_pil(self, content_json: Dict[str, Any], output_dir: str) -> List[Dict[str, Any]]:
        """
        Generate images using PIL as fallback when SVG conversion fails
        
        Args:
            content_json: Content generated by content_agent
            output_dir: Directory to save generated images
            
        Returns:
            list: Metadata about generated images
        """
        try:
            from PIL import Image, ImageDraw, ImageFont
        except ImportError:
            raise ImportError("PIL (Pillow) is required for fallback image generation")
        
        images = []
        
        # Generate cover image
        cover_path = self._create_cover_image_pil(content_json.get("cover", {}), output_dir)
        if cover_path:
            images.append({
                "type": "cover",
                "path": str(cover_path),
                "file_name": os.path.basename(cover_path),
                "status": "generated"
            })
        
        # Generate content images
        for i, page in enumerate(content_json.get("content_pages", [])):
            page_number = i + 1
            content_path = self._create_content_image_pil(page, page_number, output_dir)
            if content_path:
                images.append({
                    "type": "content",
                    "page_number": page_number,
                    "path": str(content_path),
                    "file_name": os.path.basename(content_path),
                    "status": "generated"
                })
        
        logger.info(f"Generated {len(images)} images using PIL fallback")
        return images
    
    def _create_cover_image_pil(self, cover_data: Dict[str, Any], output_dir: str) -> Path:
        """Create cover image using PIL"""
        from PIL import Image, ImageDraw, ImageFont
        
        # Create 1080x1080 image
        img = Image.new('RGB', (1080, 1080), color='white')
        draw = ImageDraw.Draw(img)
        
        # Draw border
        draw.rectangle([35, 35, 1045, 1045], outline='black', width=3)
        
        # Try to use fonts with Chinese support
        title_font = subtitle_font = text_font = None
        
        # List of fonts to try (with Chinese support)
        font_candidates = [
            # macOS
            "/System/Library/Fonts/PingFang.ttc",
            "/System/Library/Fonts/Helvetica.ttc", 
            "/Library/Fonts/Arial Unicode MS.ttf",
            # Windows
            "C:/Windows/Fonts/simsun.ttc",
            "C:/Windows/Fonts/msyh.ttc",
            "C:/Windows/Fonts/arial.ttf",
            # Linux
            "/usr/share/fonts/truetype/noto/NotoSansCJK-Regular.ttc",
            "/usr/share/fonts/truetype/liberation/LiberationSans-Regular.ttf",
            # Fallback
            "Arial.ttf"
        ]
        
        for font_path in font_candidates:
            try:
                title_font = ImageFont.truetype(font_path, 80)
                subtitle_font = ImageFont.truetype(font_path, 40)
                text_font = ImageFont.truetype(font_path, 35)
                break
            except:
                continue
        
        # Final fallback
        if not title_font:
            try:
                title_font = ImageFont.load_default()
                subtitle_font = ImageFont.load_default()
                text_font = ImageFont.load_default()
            except:
                title_font = subtitle_font = text_font = None
        
        # Draw hashtag
        hashtag = f"#{cover_data.get('hashtag', 'AI')}"
        if title_font:
            bbox = draw.textbbox((0, 0), hashtag, font=subtitle_font)
            text_width = bbox[2] - bbox[0]
            draw.text((540 - text_width//2, 100), hashtag, fill='black', font=subtitle_font)
        else:
            draw.text((480, 100), hashtag, fill='black')
        
        # Draw divider line
        draw.line([385, 175, 695, 175], fill='black', width=6)
        
        # Draw heading lines with smart sizing and wrapping
        heading1 = cover_data.get('heading_line1', 'AI Content')
        heading2 = cover_data.get('heading_line2', 'Generation')
        
        if title_font:
            # Auto-adjust font size for heading1 to fit within margins
            max_width = 950  # Leave 65px margin on each side
            current_font_size = 80
            
            # Try smaller font sizes until text fits
            working_font_path = None
            for font_path in font_candidates:
                try:
                    ImageFont.truetype(font_path, 40)  # Test if font works
                    working_font_path = font_path
                    break
                except:
                    continue
            
            if working_font_path:
                while current_font_size > 40:
                    try:
                        test_font = ImageFont.truetype(working_font_path, current_font_size)
                        bbox = draw.textbbox((0, 0), heading1, font=test_font)
                        text_width = bbox[2] - bbox[0]
                        if text_width <= max_width:
                            break
                    except:
                        pass
                    current_font_size -= 5
                
                # Use adjusted font
                heading_font = ImageFont.truetype(working_font_path, current_font_size) if current_font_size > 40 else title_font
                
                # Auto-adjust font size for heading2 (smaller than heading1)
                subtitle_font_size = max(30, current_font_size - 20)
                try:
                    subtitle_font = ImageFont.truetype(working_font_path, subtitle_font_size)
                except:
                    subtitle_font = subtitle_font
            else:
                heading_font = title_font
                subtitle_font = subtitle_font
            
            # Draw heading1 with adjusted font
            bbox = draw.textbbox((0, 0), heading1, font=heading_font)
            text_width = bbox[2] - bbox[0]
            x_pos = max(65, 540 - text_width//2)  # Ensure text doesn't go outside margins
            
            # Create bold effect for heading1
            for dx in [-1, 0, 1]:
                for dy in [-1, 0, 1]:
                    if dx == 0 and dy == 0:
                        continue
                    draw.text((x_pos + dx, 300 + dy), heading1, fill='black', font=heading_font)
            
            # Draw heading2 with smaller font
            bbox = draw.textbbox((0, 0), heading2, font=subtitle_font)
            text_width = bbox[2] - bbox[0]
            x_pos = max(65, 540 - text_width//2)  # Ensure text doesn't go outside margins
            
            # Create bold effect for heading2
            for dx in [-1, 0, 1]:
                for dy in [-1, 0, 1]:
                    if dx == 0 and dy == 0:
                        continue
                    draw.text((x_pos + dx, 450 + dy), heading2, fill='black', font=subtitle_font)
            
            # Draw main text on top (final layer)
            bbox = draw.textbbox((0, 0), heading1, font=heading_font)
            text_width = bbox[2] - bbox[0]
            x_pos = max(65, 540 - text_width//2)
            draw.text((x_pos, 300), heading1, fill='black', font=heading_font)
            
            bbox = draw.textbbox((0, 0), heading2, font=subtitle_font)
            text_width = bbox[2] - bbox[0]
            x_pos = max(65, 540 - text_width//2)
            draw.text((x_pos, 450), heading2, fill='black', font=subtitle_font)
        else:
            # Fallback for when no fonts are available - use smaller text
            draw.text((65, 300), heading1[:20] + "..." if len(heading1) > 20 else heading1, fill='black')
            draw.text((65, 450), heading2[:30] + "..." if len(heading2) > 30 else heading2, fill='black')
        
        # Draw grey box (moved down for more spacing)
        draw.rounded_rectangle([158, 780, 922, 860], radius=40, fill='#f0f0f0', outline='black', width=1)
        
        # Draw grey box text
        grey_text = cover_data.get('grey_box_text', 'Learn AI!')
        if text_font:
            bbox = draw.textbbox((0, 0), grey_text, font=text_font)
            text_width = bbox[2] - bbox[0]
            draw.text((540 - text_width//2, 805), grey_text, fill='black', font=text_font)
        else:
            draw.text((450, 805), grey_text, fill='black')
        
        # Draw social media handle at bottom center
        social_text = "@datasci_daily"
        social_y = 1020  # Position at bottom
        
        if text_font:
            bbox = draw.textbbox((0, 0), social_text, font=text_font)
            social_text_width = bbox[2] - bbox[0]
            social_x = 540 - social_text_width // 2  # Center horizontally
            draw.text((social_x, social_y), social_text, fill='#8e8e93', font=text_font)
        else:
            draw.text((490, social_y), social_text, fill='#8e8e93')
        
        # Save image directly as JPG for Instagram compatibility
        output_path = Path(output_dir) / "cover.jpg"
        
        # Convert to RGB if needed for JPG
        if img.mode in ('RGBA', 'LA') or (img.mode == 'P' and 'transparency' in img.info):
            rgb_img = Image.new('RGB', img.size, (255, 255, 255))
            rgb_img.paste(img, mask=img if img.mode == 'RGBA' else None)
            img = rgb_img
        
        img.save(output_path, "JPEG", quality=95)
        
        logger.info(f"Created cover image with PIL: {output_path}")
        return output_path
    
    def _create_content_image_pil(self, page_data: Dict[str, Any], page_number: int, output_dir: str) -> Path:
        """Create content page image using PIL"""
        from PIL import Image, ImageDraw, ImageFont
        
        # Create 1080x1080 image
        img = Image.new('RGB', (1080, 1080), color='white')
        draw = ImageDraw.Draw(img)
        
        # Draw border
        draw.rectangle([35, 35, 1045, 1045], outline='black', width=3)
        
        # Try to use fonts with Chinese support
        title_font = text_font = page_font = None
        
        # List of fonts to try (with Chinese support)
        font_candidates = [
            # macOS
            "/System/Library/Fonts/PingFang.ttc",
            "/System/Library/Fonts/Helvetica.ttc", 
            "/Library/Fonts/Arial Unicode MS.ttf",
            # Windows
            "C:/Windows/Fonts/simsun.ttc",
            "C:/Windows/Fonts/msyh.ttc",
            "C:/Windows/Fonts/arial.ttf",
            # Linux
            "/usr/share/fonts/truetype/noto/NotoSansCJK-Regular.ttc",
            "/usr/share/fonts/truetype/liberation/LiberationSans-Regular.ttf",
            # Fallback
            "Arial.ttf"
        ]
        
        for font_path in font_candidates:
            try:
                title_font = ImageFont.truetype(font_path, 60)
                text_font = ImageFont.truetype(font_path, 32)
                page_font = ImageFont.truetype(font_path, 40)
                break
            except:
                continue
        
        # Final fallback
        if not title_font:
            try:
                title_font = ImageFont.load_default()
                text_font = ImageFont.load_default()
                page_font = ImageFont.load_default()
            except:
                title_font = text_font = page_font = None
        
        # Draw page number
        page_text = f"{page_number:02d}"
        if page_font:
            draw.text((100, 100), page_text, fill='black', font=page_font)
        else:
            draw.text((100, 100), page_text, fill='black')
        
        # Draw title (with proper wrapping)
        title = page_data.get('title', f'Point {page_number}')
        title_lines = self._wrap_text(title, title_font, 800)  # More conservative width for Chinese title
        
        # Draw title lines (max 2 lines)
        title_y_start = 180
        title_line_height = 70
        
        for i, line in enumerate(title_lines[:2]):  # Max 2 lines for title
            y_pos = title_y_start + (i * title_line_height)
            if title_font:
                bbox = draw.textbbox((0, 0), line, font=title_font)
                text_width = bbox[2] - bbox[0]
                draw.text((540 - text_width//2, y_pos), line, fill='black', font=title_font)
            else:
                draw.text((300, y_pos), line, fill='black')
        
        # Draw content area background (adjust position based on title lines)
        content_y_start = 320 if len(title_lines) > 1 else 300
        content_area_height = 400
        draw.rounded_rectangle([150, content_y_start, 930, content_y_start + content_area_height], radius=20, fill='#f0f0f0', outline='black', width=1)
        
        # Draw main point text (wrapped)
        main_point = page_data.get('main_point', 'Content goes here.')
        
        # Improved text wrapping based on actual text width - more conservative for container
        # Container width is 780px (930-150), with 20px padding on each side = 740px usable
        lines = self._wrap_text(main_point, text_font, 740)  # Width adjusted for container padding
        
        # Calculate max lines that can fit in container
        line_height = 45
        max_lines = (content_area_height - 60) // line_height  # Account for padding
        
        # If we have too many lines, adjust font size and line height
        if len(lines) > max_lines:
            # Scale down font size to fit more lines
            scale_factor = max(0.7, max_lines / len(lines))
            if text_font:
                try:
                    font_candidates = [
                        "/System/Library/Fonts/PingFang.ttc",
                        "/System/Library/Fonts/Helvetica.ttc", 
                        "/Library/Fonts/Arial Unicode MS.ttf",
                        "C:/Windows/Fonts/simsun.ttc",
                        "C:/Windows/Fonts/msyh.ttc",
                        "C:/Windows/Fonts/arial.ttf",
                        "/usr/share/fonts/truetype/noto/NotoSansCJK-Regular.ttc",
                        "/usr/share/fonts/truetype/liberation/LiberationSans-Regular.ttf",
                        "Arial.ttf"
                    ]
                    
                    for font_path in font_candidates:
                        try:
                            text_font = ImageFont.truetype(font_path, int(32 * scale_factor))
                            break
                        except:
                            continue
                except:
                    pass
            
            line_height = int(line_height * scale_factor)
            # Re-wrap text with smaller font
            lines = self._wrap_text(main_point, text_font, 740)
        
        # Draw text lines within container bounds
        y_start = content_y_start + 30
        max_display_lines = min(len(lines), max_lines)
        
        for i, line in enumerate(lines[:max_display_lines]):
            y_pos = y_start + (i * line_height)
            if text_font:
                draw.text((170, y_pos), line, fill='black', font=text_font)
            else:
                draw.text((170, y_pos), line, fill='black')
        
        # Save image directly as JPG for Instagram compatibility
        output_path = Path(output_dir) / f"content_{page_number:02d}.jpg"
        
        # Convert to RGB if needed for JPG
        if img.mode in ('RGBA', 'LA') or (img.mode == 'P' and 'transparency' in img.info):
            rgb_img = Image.new('RGB', img.size, (255, 255, 255))
            rgb_img.paste(img, mask=img if img.mode == 'RGBA' else None)
            img = rgb_img
        
        img.save(output_path, "JPEG", quality=95)
        
        logger.info(f"Created content image {page_number} with PIL: {output_path}")
        return output_path
    
    def _wrap_text(self, text: str, font, max_width: int) -> List[str]:
        """Wrap text to fit within max_width pixels"""
        from PIL import Image, ImageDraw
        import re
        
        if not font:
            # Fallback for no font - use character-based wrapping for Chinese
            has_cjk = bool(re.search(r'[\u4e00-\u9fff\u3040-\u30ff\u3400-\u4dbf]', text))
            
            if has_cjk:
                # For Chinese text, wrap by character count
                chars_per_line = 20  # Conservative estimate
                lines = []
                current_line = ""
                
                for char in text:
                    if len(current_line) >= chars_per_line:
                        lines.append(current_line)
                        current_line = char
                    else:
                        current_line += char
                
                if current_line:
                    lines.append(current_line)
                return lines
            else:
                # For English text, wrap by words
                words = text.split()
                lines = []
                current_line = ""
                words_per_line = 8  # Conservative estimate
                
                for word in words:
                    if len(current_line.split()) >= words_per_line:
                        lines.append(current_line.strip())
                        current_line = word + " "
                    else:
                        current_line += word + " "
                
                if current_line.strip():
                    lines.append(current_line.strip())
                return lines
        
        # Create temporary draw object for text measurement
        temp_img = Image.new('RGB', (1, 1))
        temp_draw = ImageDraw.Draw(temp_img)
        
        # Check if text contains Chinese characters
        has_cjk = bool(re.search(r'[\u4e00-\u9fff\u3040-\u30ff\u3400-\u4dbf]', text))
        
        if has_cjk:
            # For Chinese text, wrap by character to avoid word boundary issues
            lines = []
            current_line = ""
            
            for char in text:
                test_line = current_line + char
                bbox = temp_draw.textbbox((0, 0), test_line, font=font)
                text_width = bbox[2] - bbox[0]
                
                if text_width <= max_width:
                    current_line = test_line
                else:
                    if current_line:
                        lines.append(current_line)
                        current_line = char
                    else:
                        # Single character is too long, force it
                        lines.append(char)
                        current_line = ""
            
            if current_line:
                lines.append(current_line)
            
            return lines
        else:
            # For English text, wrap by words
            words = text.split()
            lines = []
            current_line = ""
            
            for word in words:
                test_line = current_line + word + " " if current_line else word + " "
                bbox = temp_draw.textbbox((0, 0), test_line, font=font)
                text_width = bbox[2] - bbox[0]
                
                if text_width <= max_width:
                    current_line = test_line
                else:
                    if current_line:
                        lines.append(current_line.strip())
                        current_line = word + " "
                    else:
                        # Single word is too long, force it
                        lines.append(word)
                        current_line = ""
            
            if current_line.strip():
                lines.append(current_line.strip())
            
            return lines
    
    def node_handler(self, state):
        """
        Handler for LangGraph node
        
        Args:
            state: Current graph state
            
        Returns:
            Command to update state and route to next node
        """
        from langgraph.types import Command
        
        content_json = state.get("content_json", {})
        if not content_json or "error" in content_json:
            return Command(
                update={
                    "messages": [
                        HumanMessage(
                            content="Error: Invalid content JSON. Cannot generate images.", 
                            name="image_agent"
                        )
                    ],
                    "images": []
                },
                goto="supervisor",
            )
        
        # Create dated output directory
        import tempfile
        from datetime import datetime
        
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        
        # Determine base output directory
        base_output_dir = self.output_dir or Path(tempfile.gettempdir())
        
        # Create dated subdirectory structure
        date_folder = datetime.now().strftime("%Y-%m-%d")
        output_dir = Path(base_output_dir) / date_folder / timestamp
        os.makedirs(output_dir, exist_ok=True)
        
        logger.info(f"Creating output in: {output_dir}")
        
        # Generate images
        all_images = self.generate_images(content_json, output_dir)
        
        return Command(
            update={
                "messages": [
                    HumanMessage(
                        content=f"Generated {len(all_images)} images. Cover and {len(all_images)-1} content pages created successfully.", 
                        name="image_agent"
                    )
                ],
                "images": all_images,
                "output_dir": str(output_dir)
            },
            goto="supervisor",
        )